import os, sys, csv, math
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib import rc
from pathlib import Path
import seaborn as sns
import matplotlib as mpl
sns.set(font_scale=1.3)
sns.set_style('ticks')
csv.field_size_limit(2147483647)

### GROWTH CURVE GRAPHING FUNCTIONS ###
# Function to convert growth curve data from a .csv file into a pandas dataframe for processing/graphing
# Returns: A pandas dataframe with headers 'Strain', 'Treatment', 'OD600', 'Hours'
# dataDF: The Dataframe generated by pd.read_csv() of a .csv file with growth curve data in it.
#       This function expects that data to have headers: "Hours", "A1", "A2", etc. The "Hours" header is required.
# strainLocs: A 2D list in the format list[row][column] representing what strains were in what wells of the 96 well plate. Empty wells must have an empty string.
# treatmentLocs: A 2D list in the format list[row][column] representing what treatments were in what wells of the 96 well plate. Empty wells must have an empty string.
def curveData2df(dataDF, strainLocs, treatmentLocs):
    if len(strainLocs) != 8:
        raise Exception('Error: The strainLocs argument has the wrong number of rows (must be 8).')
    if len(treatmentLocs) != 8:
        raise Exception('Error: The treatmentLocs argument has the wrong number of rows (must be 8).')
    for i in range(len(strainLocs)):
        if len(strainLocs[i]) != 12:
            raise Exception(f'Error: The strainLocs argument has the wrong number of columns in row {str(i + 1)} (must be 12).')
        if len(treatmentLocs[i]) != 12:
            raise Exception(f'Error: The treatmentLocs argument has the wrong number of columns in row {str(i + 1)} (must be 12).')
    dataDict = {'Strain':[], 'Treatment':[], 'OD600':[], 'Hours':[]}
    hrs = []
    for x in dataDF['Hours']:
        hrs.append(x)
    letterIndex = {'A':0, 'B':1, 'C':2, 'D':3, 'E':4, 'F':5, 'G':6, 'H':7}
    for k in dataDF.keys():
        if k == 'Hours':
            continue
        rowVal = letterIndex[k[0]]
        colVal = int(k[1:]) - 1
        strain = strainLocs[rowVal][colVal]
        treatment = treatmentLocs[rowVal][colVal]
        for i in range(len(dataDF[k])):
            dataDict['OD600'].append(dataDF[k][i])
            dataDict['Hours'].append(hrs[i])
            dataDict['Strain'].append(strain)
            dataDict['Treatment'].append(treatment)
    return pd.DataFrame(dataDict)
    
# Returns: A subset DataFrame of "df" with only data from the specified strain
# df: A DataFrame generated by the curveData2df function. It will have the headers 'Treatment', 'OD600', 'Hours'
# strain: A string representing one of the strains in df
# If normToNegative is True, subtracts the average OD of the negative control for that treatment at each timepoint measurement
# If time limit is set, will only return up to the given time point in hours (inclusive)
# If treatments is set to a list, will only return values for those treatments
def sliceDFByStrain(df, strain, normToNegative=True, timeLimit=1000000000000, treatments=None):
    treatmentData = []
    odData = []
    timeData = []
    negData = []
    negTimes = []
    negTreatments = []
    for index, row in df.iterrows():
        if row['Strain'] == strain and row['Hours'] <= timeLimit:
            if treatments != None and not row['Treatment'] in treatments:
                continue
            treatmentData.append(row['Treatment'])
            odData.append(row['OD600'])
            timeData.append(row['Hours'])
        if normToNegative and row['Strain'] == 'Negative':
            negData.append(row['OD600'])
            negTimes.append(row['Hours'])
            negTreatments.append(row['Treatment'])
    toReturnOD = []
    if normToNegative:
        times = set()
        for x in timeData:
            times.add(x)
        treatments = set()
        for x in treatmentData:
            treatments.add(x)
        negDict = {} #key='timestamp treatment', value=average of all negative values at that time
        negHolder = {} #key='timestamp treatment', value=list of absorbances for that combination
        for t in times:
            for tr in treatments:
                keystamp = f'{str(t)} {str(tr)}'
                negValues = []
                for i in range(len(negData)):
                    if negTimes[i] == t and negTreatments[i] == tr:
                        negValues.append(negData[i])
                negDict[keystamp] = sum(negValues) / len(negValues)
        for i in range(len(odData)):
            keystamp = f'{str(timeData[i])} {str(treatmentData[i])}'
            toReturnOD.append(odData[i] - negDict[keystamp])
    else:
        toReturnOD = odData
    return pd.DataFrame({'Treatment':treatmentData, 'OD600':toReturnOD, 'Hours':timeData})

### OBJECTS ###
# Object used to store information about a protein. Only stores the protein ID, its aa sequence
# By default, initializes without strain information. If initWithStrains is True, reads in strains from the "OS=" decorator
class SimpleProtein:
    def __init__(self, entry, initWithStrains=False):
        self.id = self.extractProteinID(entry)
        self.strains = set()
        if initWithStrains:
            self.extractStrains(entry)
        self.sequence = entry[entry.find('\n') + 1:].replace('\n', '')

    # This function takes a single protein entry from a .fasta file and returns the protein identifier for that entry.
    def extractProteinID(self, entry):
        stringEnd = entry.find(' ')
        return entry[0:stringEnd]
    
    # Adds the strains from the entry to this SimpleProtein object
    def extractStrains(self, entry):
        stringStart = entry.find('OS=') + 3
        stringEnd = entry.find('\n')
        strainList = entry[stringStart:stringEnd].split(';')
        for s in strainList:
            self.strains.add(s)
    
    # Adds the specified taxa name to this protein's list of taxa, assuming the new taxa is not already in it
    def addStrain(self, strain):
        self.strains.add(strain)
    
    # Get the fasta entry for this protein, including all taxa that encode it
    def getEntry(self):
        taxaList = []
        for s in self.strains:
            taxaList.append(s)
        taxaEntry = ''
        for i in range(len(taxaList)):
            if i == len(taxaList) - 1:
                taxaEntry = f'{taxaEntry}{taxaList[i]}'
            else:
                taxaEntry = f'{taxaEntry}{taxaList[i]};'
        return f'>{self.id} OS={taxaEntry}\n{self.sequence}\n'

### FIGURE FUNCTIONS ###
# Convenience function that saves a 300DPI PNG of the specified figure to the specified filePath
def saveFig(figure, filePath):
    figure.get_figure().savefig(filePath, bbox_inches='tight', dpi=300)